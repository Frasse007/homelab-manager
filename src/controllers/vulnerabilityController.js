const { Vulnerability, Service } = require('../models');
const { successResponse } = require('../utils/responseFormatter.js');
const { NotFoundError, AuthorizationError } = require('../utils/errors.js');

// GET /api/vulnerabilities - Gets all vulnerabilities
async function getAllVulnerabilities(req, res, next) {
    try {
        // Takes input and initializes an "empty query" to be used later
        const { service_id, severity, status } = req.query;
        const where = {};

        // Adds the filters to the query
        if (service_id) where.service_id = service_id;
        if (severity) where.severity = severity;
        if (status) where.status = status;

        const include = [{ model: Service, as: 'service' }];

        // Ensures non-admins can only see vulnerabilities for their own services
        if (req.user.role !== 'admin') {
            include[0].where = { user_id: req.user.id };
        }

        // Queries the database with filters provided
        const vulnerabilities = await Vulnerability.findAll({
            where,
            include,
            order: [
                ['severity', 'ASC'],
                ['discovered_date', 'DESC']
            ]
        });

        // Returns success message with vulnerabilities
        successResponse(res, vulnerabilities, 'Vulnerabilities retrieved successfully');
    } catch (error) {
        next(error);
    }
};

// GET /api/vulnerabilities/:id - Gets single vulnerability by its ID
async function getVulnerabilityById(req, res, next) {
    try {
        const { id } = req.params;

        // Returns all information available about vulnerability with provided ID
        const vulnerability = await Vulnerability.findByPk(id, {
            include: [{ model: Service, as: 'service' }]
        });

        // Throws custom 'NotFoundError' if vulnerability doesn't exist
        if (!vulnerability) {
            throw new NotFoundError('Vulnerability not found');
        }

        // Throws custom 'AuthorizationError' if user doesn't own the associated service or is admin
        if (req.user.role !== 'admin' && vulnerability.service.user_id !== req.user.id) {
            throw new AuthorizationError('You can only access vulnerabilities for your own services');
        }

        // Returns success message with vulnerability information
        successResponse(res, vulnerability, 'Vulnerability retrieved successfully');
    } catch (error) {
        next(error);
    }
};

// POST /api/vulnerabilities - Creates new vulnerability
async function createVulnerability(req, res, next) {
    try {
        const { service_id } = req.body;

        // Checks if associated service exists
        const service = await Service.findByPk(service_id);

        if (!service) {
            throw new NotFoundError('Service not found');
        }

        // Throws custom 'AuthorizationError' if user doesn't own service or is admin
        if (req.user.role !== 'admin' && service.user_id !== req.user.id) {
            throw new AuthorizationError('You can only create vulnerabilities for your own services');
        }

        // Creates new vulnerability with input from user
        const vulnerability = await Vulnerability.create(req.body);

        // Fetches full data including associations to return to user
        const fullVulnerability = await Vulnerability.findByPk(vulnerability.id, {
            include: [{ model: Service, as: 'service' }]
        });

        // Returns success message with vulnerability information
        successResponse(res, fullVulnerability, 'Vulnerability created successfully', 201);
    } catch (error) {
        next(error);
    }
};

// PUT /api/vulnerabilities/:id - Updates information for a vulnerability by its ID
async function updateVulnerability(req, res, next) {
    try {
        const { id } = req.params;

        // Finds the vulnerability by its ID
        const vulnerability = await Vulnerability.findByPk(id, {
            include: [{ model: Service, as: 'service' }]
        });

        // Throws custom 'NotFoundError' if vulnerability doesn't exist
        if (!vulnerability) {
            throw new NotFoundError('Vulnerability not found');
        }

        // Throws custom 'AuthorizationError' if user doesn't own the associated service or is admin
        if (req.user.role !== 'admin' && vulnerability.service.user_id !== req.user.id) {
            throw new AuthorizationError('You can only update vulnerabilities for your own services');
        }

        // Updates vulnerability with input
        await vulnerability.update(req.body);

        // Fetches updated record
        const updatedVulnerability = await Vulnerability.findByPk(id, {
            include: [{ model: Service, as: 'service' }]
        });

        // Returns success message with vulnerability information
        successResponse(res, updatedVulnerability, 'Vulnerability updated successfully');
    } catch (error) {
        next(error);
    }
};

// DELETE /api/vulnerabilities/:id - Deletes a vulnerability by its ID
async function deleteVulnerability(req, res, next) {
    try {
        const { id } = req.params;

        // Finds the vulnerability by its ID
        const vulnerability = await Vulnerability.findByPk(id, {
            include: [{ model: Service, as: 'service' }]
        });

        // Throws custom 'NotFoundError' if vulnerability doesn't exist
        if (!vulnerability) {
            throw new NotFoundError('Vulnerability not found');
        }

        // Throws custom 'AuthorizationError' if user doesn't own the associated service or is admin
        if (req.user.role !== 'admin' && vulnerability.service.user_id !== req.user.id) {
            throw new AuthorizationError('You can only delete vulnerabilities for your own services');
        }

        // Deletes vulnerability
        await vulnerability.destroy();

        // Returns success message
        successResponse(res, null, 'Vulnerability deleted successfully');
    } catch (error) {
        next(error);
    }
};

// GET /api/vulnerabilities/stats - Gets vulnerability statistics
async function getVulnerabilityStats(req, res, next) {
    try {
        // Logic to give admins complete overview but users only their own services
        const serviceWhere = req.user.role === 'admin' ? {} : { user_id: req.user.id };
        const include = [{ model: Service, as: 'service', where: serviceWhere, attributes: [] }];

        // Calculate total vulnerabilities and breakdown by severity and status
        const [total, critical, high, medium, low, open, patched] = await Promise.all([
            Vulnerability.count({ include }),
            Vulnerability.count({ where: { severity: 'Critical' }, include }),
            Vulnerability.count({ where: { severity: 'High' }, include }),
            Vulnerability.count({ where: { severity: 'Medium' }, include }),
            Vulnerability.count({ where: { severity: 'Low' }, include }),
            Vulnerability.count({ where: { status: 'open' }, include }),
            Vulnerability.count({ where: { status: 'patched' }, include })
        ]);

        // Organizes information about vulnerabilities obtained above
        const stats = {
            total,
            by_severity: {
                critical,
                high,
                medium,
                low
            },
            by_status: {
                open,
                patched,
                other: total - open - patched
            }
        };

        // Returns success message with vulnerability stats
        successResponse(res, stats, 'Vulnerability statistics retrieved successfully');
    } catch (error) {
        next(error);
    }
};

module.exports = {
    getAllVulnerabilities,
    getVulnerabilityById,
    getVulnerabilityById,
    createVulnerability,
    updateVulnerability,
    deleteVulnerability,
    getVulnerabilityStats
};