const request = require('supertest');
const app = require('../../src/app.js');
const { sequelize } = require('../../src/models/index.js');
const { getAuthToken } = require('../utils/test.js');

describe('Vulnerability Endpoints', () => {
  let authToken;
  let testService;

  beforeEach(async () => {
    // Create and login a test user
    const auth = await getAuthToken();
    authToken = auth.token;

    // Create a test service
    const serviceRes = await request(app)
      .post('/api/services')
      .set('Authorization', `Bearer ${authToken}`)
      .send({
        service_name: 'Vulnerable Service',
        url: 'http://192.168.1.100:8080',
        service_type: 'other',
        status: 'running'
      });
    
    testService = serviceRes.body.data;
  });

  afterAll(async () => {
    await sequelize.close();
  });

  describe('POST /api/vulnerabilities', () => {
    it('should create a new vulnerability with all required fields', async () => {
      const response = await request(app)
        .post('/api/vulnerabilities')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          service_id: testService.id,
          title: 'SQL Injection Vulnerability',
          description: 'SQL injection vulnerability in login form',
          severity: 'Critical'
        });

      expect(response.status).toBe(201);
      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveProperty('title', 'SQL Injection Vulnerability');
      expect(response.body.data).toHaveProperty('severity', 'Critical');
      expect(response.body.data).toHaveProperty('service_id', testService.id);
      expect(response.body.data).toHaveProperty('status', 'open');
    });

    it('should fail without authentication', async () => {
      const response = await request(app)
        .post('/api/vulnerabilities')
        .send({
          service_id: testService.id,
          title: 'XSS Vulnerability',
          description: 'Cross-site scripting vulnerability',
          severity: 'High'
        });

      expect(response.status).toBe(401);
      expect(response.body.success).toBe(false);
    });

    it('should fail with missing title', async () => {
      const response = await request(app)
        .post('/api/vulnerabilities')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          service_id: testService.id,
          description: 'Test description',
          severity: 'Medium'
        });

      expect(response.status).toBe(400);
      expect(response.body.success).toBe(false);
    });

    it('should fail with title exceeding 255 characters', async () => {
      const response = await request(app)
        .post('/api/vulnerabilities')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          service_id: testService.id,
          title: 'A'.repeat(256),
          description: 'Test description',
          severity: 'Medium'
        });

      expect(response.status).toBe(400);
      expect(response.body.success).toBe(false);
    });

    it('should fail with non-existent service_id', async () => {
      const response = await request(app)
        .post('/api/vulnerabilities')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          service_id: 99999,
          title: 'Test Vuln',
          description: 'Test description',
          severity: 'High'
        });

      expect(response.status).toBe(404);
      expect(response.body.success).toBe(false);
    });

    it('should accept all valid severity levels', async () => {
      const severities = ['Critical', 'High', 'Medium', 'Low', 'Informational'];
      
      for (const severity of severities) {
        const response = await request(app)
          .post('/api/vulnerabilities')
          .set('Authorization', `Bearer ${authToken}`)
          .send({
            service_id: testService.id,
            title: `${severity} Vulnerability`,
            description: `Test ${severity} vulnerability`,
            severity: severity
          });

        expect(response.status).toBe(201);
        expect(response.body.data).toHaveProperty('severity', severity);
      }
    });

    it('should accept all valid status values', async () => {
      const statuses = ['open', 'in_progress', 'patched', 'mitigated', 'accepted'];
      
      for (const status of statuses) {
        const response = await request(app)
          .post('/api/vulnerabilities')
          .set('Authorization', `Bearer ${authToken}`)
          .send({
            service_id: testService.id,
            title: `Vulnerability with ${status} status`,
            description: `Test vulnerability`,
            severity: 'Medium',
            status: status
          });

        expect(response.status).toBe(201);
        expect(response.body.data).toHaveProperty('status', status);
      }
    });
  });

  describe('GET /api/vulnerabilities', () => {
    beforeEach(async () => {
      // Create multiple vulnerabilities to use in test
      await request(app)
        .post('/api/vulnerabilities')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          service_id: testService.id,
          title: 'SQL Injection',
          description: 'SQL injection in login',
          severity: 'Critical',
          status: 'open'
        });

      await request(app)
        .post('/api/vulnerabilities')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          service_id: testService.id,
          title: 'XSS Vulnerability',
          description: 'Cross-site scripting',
          severity: 'High',
          status: 'patched'
        });

      await request(app)
        .post('/api/vulnerabilities')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          service_id: testService.id,
          title: 'Weak Password Policy',
          description: 'Password requirements too weak',
          severity: 'Low',
          status: 'open'
        });
    });

    it('should get all vulnerabilities for authenticated user', async () => {
      const response = await request(app)
        .get('/api/vulnerabilities')
        .set('Authorization', `Bearer ${authToken}`);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(Array.isArray(response.body.data)).toBe(true);
      expect(response.body.data.length).toBeGreaterThanOrEqual(3);
    });

    it('should filter vulnerabilities by severity', async () => {
      const response = await request(app)
        .get('/api/vulnerabilities?severity=Critical')
        .set('Authorization', `Bearer ${authToken}`);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      response.body.data.forEach(vuln => {
        expect(vuln.severity).toBe('Critical');
      });
    });

    it('should filter vulnerabilities by status', async () => {
      const response = await request(app)
        .get('/api/vulnerabilities?status=open')
        .set('Authorization', `Bearer ${authToken}`);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      response.body.data.forEach(vuln => {
        expect(vuln.status).toBe('open');
      });
    });

    it('should filter vulnerabilities by service_id', async () => {
      const response = await request(app)
        .get(`/api/vulnerabilities?service_id=${testService.id}`)
        .set('Authorization', `Bearer ${authToken}`);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      response.body.data.forEach(vuln => {
        expect(vuln.service_id).toBe(testService.id);
      });
    });

    it('should fail without authentication', async () => {
      const response = await request(app)
        .get('/api/vulnerabilities');

      expect(response.status).toBe(401);
      expect(response.body.success).toBe(false);
    });

  describe('GET /api/vulnerabilities/:id', () => {
    let vulnerabilityId;

    // Creates vulnerability to use for tests
    beforeEach(async () => {
      const createResponse = await request(app)
        .post('/api/vulnerabilities')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          service_id: testService.id,
          title: 'Vulnerability for Get Test',
          description: 'Test description for getting by ID',
          severity: 'High'
        });
      vulnerabilityId = createResponse.body.data.id;
    });

    it('should get vulnerability by id', async () => {
      const response = await request(app)
        .get(`/api/vulnerabilities/${vulnerabilityId}`)
        .set('Authorization', `Bearer ${authToken}`);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveProperty('id', vulnerabilityId);
      expect(response.body.data).toHaveProperty('title', 'Vulnerability for Get Test');
    });

    it('should return 404 for non-existent vulnerability', async () => {
      const response = await request(app)
        .get('/api/vulnerabilities/99999')
        .set('Authorization', `Bearer ${authToken}`);

      expect(response.status).toBe(404);
      expect(response.body.success).toBe(false);
    });

    it('should fail without authentication', async () => {
      const response = await request(app)
        .get(`/api/vulnerabilities/${vulnerabilityId}`);

      expect(response.status).toBe(401);
      expect(response.body.success).toBe(false);
    });
  });

  describe('PUT /api/vulnerabilities/:id', () => {
    let vulnerabilityId;

    // Creates vulnerability to use for tests
    beforeEach(async () => {
      const createResponse = await request(app)
        .post('/api/vulnerabilities')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          service_id: testService.id,
          title: 'Vulnerability for Update Test',
          description: 'Original description',
          severity: 'Medium',
          status: 'open'
        });
      vulnerabilityId = createResponse.body.data.id;
    });

    it('should update vulnerability', async () => {
      const response = await request(app)
        .put(`/api/vulnerabilities/${vulnerabilityId}`)
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          title: 'Updated Vulnerability Title',
          severity: 'Critical',
          status: 'in_progress',
          remediation_notes: 'Apply security patch immediately'
        });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveProperty('title', 'Updated Vulnerability Title');
      expect(response.body.data).toHaveProperty('severity', 'Critical');
      expect(response.body.data).toHaveProperty('status', 'in_progress');
      expect(response.body.data).toHaveProperty('remediation_notes', 'Apply security patch immediately');
    });

    it('should update only specified fields', async () => {
      const response = await request(app)
        .put(`/api/vulnerabilities/${vulnerabilityId}`)
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          status: 'patched',
          patched_date: '2024-02-01T14:30:00Z'
        });

      expect(response.status).toBe(200);
      expect(response.body.data).toHaveProperty('status', 'patched');
      expect(response.body.data).toHaveProperty('title', 'Vulnerability for Update Test');
    });

    it('should fail with invalid severity', async () => {
      const response = await request(app)
        .put(`/api/vulnerabilities/${vulnerabilityId}`)
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          severity: 'invalid'
        });

      expect(response.status).toBe(400);
      expect(response.body.success).toBe(false);
    });

    it('should fail with invalid CVE format', async () => {
      const response = await request(app)
        .put(`/api/vulnerabilities/${vulnerabilityId}`)
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          cve_id: 'BAD-FORMAT'
        });

      expect(response.status).toBe(400);
      expect(response.body.success).toBe(false);
    });

    it('should fail with CVSS score out of range', async () => {
      const response = await request(app)
        .put(`/api/vulnerabilities/${vulnerabilityId}`)
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          cvss_score: 11.0
        });

      expect(response.status).toBe(400);
      expect(response.body.success).toBe(false);
    });

    it('should return 404 for non-existent vulnerability', async () => {
      const response = await request(app)
        .put('/api/vulnerabilities/99999')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          status: 'patched'
        });

      expect(response.status).toBe(404);
      expect(response.body.success).toBe(false);
    });
  });

  describe('DELETE /api/vulnerabilities/:id', () => {
    let vulnerabilityId;

    // Creates vulnerability to use for tests
    beforeEach(async () => {
      const createResponse = await request(app)
        .post('/api/vulnerabilities')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          service_id: testService.id,
          title: 'Vulnerability for Delete Test',
          description: 'This will be deleted',
          severity: 'Low'
        });
      vulnerabilityId = createResponse.body.data.id;
    });

    it('should delete vulnerability', async () => {
      const response = await request(app)
        .delete(`/api/vulnerabilities/${vulnerabilityId}`)
        .set('Authorization', `Bearer ${authToken}`);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);

      // Verifies vulnerability is deleted
      const getResponse = await request(app)
        .get(`/api/vulnerabilities/${vulnerabilityId}`)
        .set('Authorization', `Bearer ${authToken}`);

      expect(getResponse.status).toBe(404);
    });

    it('should return 404 for non-existent vulnerability', async () => {
      const response = await request(app)
        .delete('/api/vulnerabilities/99999')
        .set('Authorization', `Bearer ${authToken}`);

      expect(response.status).toBe(404);
      expect(response.body.success).toBe(false);
    });

    it('should not allow a user to delete another users vulnerability', async () => {
      // Creates and logs in the hacker user
      await request(app)
        .post('/api/auth/register')
        .send({
          username: 'hacker',
          email: 'hacker@ex.com',
          password: 'Password123!',
          first_name: 'Hack',
          last_name: 'Er'
        });

      const loginRes = await request(app)
        .post('/api/auth/login')
        .send({
          identifier: 'hacker',
          password: 'Password123!'
        });

      const hackerToken = loginRes.body.data.token;
      
      // Tests if hacker can delete other users vulnerabilities
      const response = await request(app)
        .delete(`/api/vulnerabilities/${vulnerabilityId}`)
        .set('Authorization', `Bearer ${hackerToken}`);

      expect(response.status).toBe(403);
      expect(response.body.success).toBe(false);
    });
  });

  describe('GET /api/vulnerabilities/stats', () => {
    beforeEach(async () => {
      // Creates vulnerabilities with different severities and statuses
      await request(app)
        .post('/api/vulnerabilities')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          service_id: testService.id,
          title: 'Critical Vuln 1',
          description: 'Critical vulnerability',
          severity: 'Critical',
          status: 'open'
        });

      await request(app)
        .post('/api/vulnerabilities')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          service_id: testService.id,
          title: 'High Vuln 1',
          description: 'High severity vulnerability',
          severity: 'High',
          status: 'patched'
        });

      await request(app)
        .post('/api/vulnerabilities')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          service_id: testService.id,
          title: 'Medium Vuln 1',
          description: 'Medium severity vulnerability',
          severity: 'Medium',
          status: 'patched'
        });

      await request(app)
        .post('/api/vulnerabilities')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          service_id: testService.id,
          title: 'Low Vuln 1',
          description: 'Low severity vulnerability',
          severity: 'Low',
          status: 'open'
        });

      await request(app)
        .post('/api/vulnerabilities')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          service_id: testService.id,
          title: 'Info Vuln 1',
          description: 'Informational finding',
          severity: 'Informational',
          status: 'open'
        });
    });

    it('should get vulnerability statistics', async () => {
      const response = await request(app)
        .get('/api/vulnerabilities/stats')
        .set('Authorization', `Bearer ${authToken}`);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.data).toHaveProperty('total');
      expect(response.body.data.total).toBeGreaterThanOrEqual(5);
    });

    it('should include breakdown by severity', async () => {
      const response = await request(app)
        .get('/api/vulnerabilities/stats')
        .set('Authorization', `Bearer ${authToken}`);

      expect(response.status).toBe(200);
      expect(response.body.data).toHaveProperty('by_severity');
      expect(response.body.data.by_severity).toHaveProperty('critical');
      expect(response.body.data.by_severity).toHaveProperty('high');
      expect(response.body.data.by_severity).toHaveProperty('medium');
      expect(response.body.data.by_severity).toHaveProperty('low');
      expect(response.body.data.by_severity.critical).toBeGreaterThanOrEqual(1);
    });

    it('should include breakdown by status', async () => {
      const response = await request(app)
        .get('/api/vulnerabilities/stats')
        .set('Authorization', `Bearer ${authToken}`);

      expect(response.status).toBe(200);
      expect(response.body.data).toHaveProperty('by_status');
      expect(response.body.data.by_status).toHaveProperty('open');
      expect(response.body.data.by_status).toHaveProperty('patched');
      expect(response.body.data.by_status.open).toBeGreaterThanOrEqual(2);
    });

    it('should fail without authentication', async () => {
      const response = await request(app)
        .get('/api/vulnerabilities/stats');

      expect(response.status).toBe(401);
      expect(response.body.success).toBe(false);
    });
  });
});
});